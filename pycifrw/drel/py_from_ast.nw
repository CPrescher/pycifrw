@ These routines convert a dREL AST into Python text and were originally in the direct
conversion code.

<<*>>=
import re
<<AST builder>>
<<AST traverser>>
<<Function transformer>>
<<With finder>>
<<Utility functions>>

@  The AST builder puts the infrastructure around the statement list to turn it into a
function call with two arguments: a dictionary and a data file.  The target id will
usually be the dataname that is being defined. We always call this ``__dreltarget''
within the generated method and so need to catch references to the target_id.

The generated function can be called to generate all values in a loop column, or only
a single value, by setting keyword argument ``packet_no'' to the required packet, or
-1.

<<AST builder>>=
def make_python_function(in_ast,func_name,targetname,special_ids=[{}],cat_meth=False, have_sn=True,loopable=[]):
    """Convert in_ast to python code"""
    print "incoming AST:"
    print `in_ast`
    func_text,withtable = start_traverse(in_ast,target_id=targetname,cat_meth=cat_meth,loopable=loopable)
    print 'Start========'
    print func_text
    print 'End=========='
    # now indent the string
    noindent = func_text.splitlines()
    # get the minimum indent and remove empty lines
    no_spaces = [re.match(r' *',a).end() for a in noindent if a] #drop empty lines
    min_spaces = min(no_spaces)+4   # because we add 4 ourselves to everything
    if len(withtable) > 0:  # a loop method
        <<Create function header for loop>>
    else:
        <<Create function header for unlooped data>>
    if cat_meth:
        preamble += " "*8 + "__dreltarget = {}\n" # initialise
    indented = map(lambda a:" "*8 + a +"\n",noindent)  #indent dREL body
    postamble = ""
    postamble += " "*8 + "return __dreltarget"
    final = preamble + "".join(indented) + postamble
    return final

@  Creating functions for looped categories.  We provide a shell function which
internally calls the transformed function with the option of performing the
calculation on a single packet or on the whole category.

<<Create function header for loop>>=
    dummy_vars = [a[0] for a in withtable.items()]
    dummy_vars = ",".join(dummy_vars)
    actual_names = [k for k in withtable.keys()]
    actual_names = ["ciffile[repr(a)]" for a in actual_names]
    map_names = ",".join(actual_names)
    one_pack_names = [a+"[packet_no]" for a in actual_names]
    one_packet_each = ",".join(one_pack_names)
    preamble = "def %s(self,ciffile,packet_no=-1):\n" % (func_name)
    preamble += "    if packet_no < 0:   #map\n"""
    preamble  +="        return map(lambda %s: drel_func(self,ciffile,%s),%s)\n" % (dummy_vars,dummy_vars,map_names)
    preamble  +="    else:\n"
    preamble  +="        return drel_func(self,ciffile,%s)\n" % one_packet_each
    preamble  +="    def drel_func(dic,cifdata,%s):\n" % dummy_vars

@ Un'with'ed data can simply be called with the dictionary and ciffile, with no
need for any extra variables

<<Create function header for unlooped data>>=
    preamble = "def %s(self,ciffile):\n" % func_name

@  The AST traverser is a recursive function which is passed a node.  It returns
a string.  We define it inside an external function so that our global variables
are actually just local variables of the enclosing function. Variable 
[[special_info.[special_id] ]] is a list of scopes, each containing a table of variables that need to be specially 
handled, either because they correspond to datanames (first entry in list) or to variables that have been aliased to categories via loop or with statements.
A variable defined in a loop statement will also have a loop index that
needs to be incremented and used to index a packet; this is the second entry in the list
indexed by the variable alias. The second entry is also used to hold the
dummy variable for the 'with' statement.  The final function can be mapped across the
keys of the with table to calculate the whole column of a category.

The final boolean entry determines whether the second entry is for looping (True) or
not (False).

<<AST traverser>>=
def start_traverse(in_node,target_id=None,loopable=[],cat_meth=False):
  special_info = {"special_id":[{}],"target_id":target_id,"withtable":{},"sub_subject":"","loopable_cats":loopable}
  <<Maths operator conversion table>>
  def traverse_ast(in_node):
    if isinstance(in_node,basestring):
        return in_node
    if isinstance(in_node[0],list):
        raise SyntaxError, 'First element of AST Node must be string: ' + `in_node`
    node_type = in_node[0]
    if node_type == "ARGLIST":
        pass
<<Literal nodes>>
<<Other primaries>>
<<Maths>>
<<Compound statements>>
<<Top level constructions>>
    else:
       return "Not found: %s" % `in_node`
  result = traverse_ast(in_node)
  return result,special_info["withtable"]

@  These are the simple constants that we have detected.

<<Literal nodes>>=
    elif node_type == "BINARY":
        return("%d" % int(in_node[1],base=2))
    elif node_type == "FALSE":
        return("False")
    elif node_type == "REAL":
        return(in_node[1])
    elif node_type == "HEX":
        return("%d" % int(in_node[1],base=16))
    elif node_type == "INT":
        return(in_node[1])
    elif node_type == "IMAGINARY":
        return(in_node[1])
    elif node_type == "OCTAL":
        return("%d" % int(in_node[1],base=8))

@  We need to catch all variables and other primary items here. Note that
for now literals are simply repeated, as the Python representation is
the same as the dREL representation. 
    
<<Other primaries>>=
    elif node_type == "ATOM":
        if isinstance(in_node[1],basestring):
            return in_node[1]
        else:
            return traverse_ast(in_node[1])
    elif node_type == "ITEM_TAG":
        if special_info.get("target_id","") == in_node[1]:
            return "__dreltarget"
        else:
            return "ciffile['%s']" % in_node[1]
    elif node_type == "LITERAL":
        return in_node[1]
    elif node_type == "LIST":
        if len(in_node)==1:  #empty list
           return "[]"
        outstring = "["
        for list_elem in in_node[1:]:
            outstring = outstring + traverse_ast(list_elem) + ","
        return outstring + "]"
    elif node_type == "SUBSCRIPTION":  # variable, expression list
        # check to see if this is a special variable
        newid = 0
        primary = traverse_ast(in_node[1])
        for idtable in special_info["special_id"]:
            newid = idtable.get(primary,0)
            if newid: break
        if newid:
            key_item = 'self["'+newid[0]+'"]["_category.key_id"]'
            get_loop = "ciffile.GetLoop(%s).GetKeyedPacket(%s,%s)" % (key_item,key_item,traverse_ast(in_node[2]))
            special_info["sub_subject"] = "_"+newid[0]  #in case of attribute reference following
            print "Set sub_subject to %s" % special_info["sub_subject"]
            return get_loop
        else:
            outstring = primary + "[ "   #extra space for empty list - see :-1 below
            for expr in in_node[2]:
                outstring = outstring + traverse_ast(expr) + ","
            return outstring[:-1] + "]"
    <<Process attribute reference>>
    elif node_type == "FUNC_CALL":
            func_name,arg_prefix,postfix = get_function_name(in_node[1])
            outstring = func_name + "( "
            for argument in in_node[2]:
                outstring = outstring + arg_prefix + traverse_ast(argument) + ","
            outstring = outstring[:-1] + ")" + postfix
            return outstring
    elif node_type == "SLICE":  # primary [start,finish,step]
        outstring = traverse_ast(in_node[1]) + "["
        slice_list = in_node[2]
        if len(slice_list) == 0:
            return outstring + ":]"
        if len(slice_list) >0:    # at least start
            outstring += traverse_ast(slice_list[0]) + ":"
        if len(slice_list) == 1:    #start only
            return outstring + "]"
        outstring += traverse_ast(slice_list[1])
        if len(slice_list) == 3:    #step as well
          outstring += ":" + traverse_ast(slice_list[2])
        outstring += "]"
        return outstring

@  Attribute references.  We need to catch all attribute references to special
variables (those defined by loop or with statements).  For ``with'' variables, we
create a dummy variable for every attribute reference, keyed by the actual
dataname formed from the variable.object syntax.  We store the order that
it appears in the function call that is created, so that we can include the function
within a 'map' statement and give the correct order of items.  So the withtable
has syntax {``dataname'':(dummyname,dummyorder)}.

<<Process attribute reference>>=
elif node_type == "ATTRIBUTE":  # id , att
    # check for special ids
    outstring = ""
    primary = traverse_ast(in_node[1])
    for idtable in special_info["special_id"]:
        newid = idtable.get(primary,0)
        if newid: break
    if newid:
        # if we are looping, we add a loop prefix. If we are withing an
        # unlooped category, we put the full name back.
        if newid[2] or (not newid[2] and not newid[1]):   # looping or simple with
            outstring = "ciffile[" + '"_' + newid[0] + "." + in_node[2]+'"]'
            if newid[1]:  # a loop statement requires an index
                outstring += "[" + newid[1]+ "]"
        else:   # a with statement; capture the name and create a dummy variable
            var_name = "_" + newid[1]+"." + in_node[2]
            if not special_info["withtable"].has_key(var_name):  #new
                position = len(special_info["withtable"])
                new_var = "__w%d" % position
                special_info["withtable"][var_name] = (new_var,position)
            outstring += special_info["withtable"][var_name][0]
    elif special_info["special_id"][0].has_key(primary+"."+in_node[2]):
        # a simple cat.obj dataname from the dictionary
        outstring = "ciffile['" + in_node[1] + "." + in_node[2] +"']"
    else: # default to Python attribute access
        outstring = "getattr(" + primary + ",'" + special_info['sub_subject'] + in_node[2] + "')"
        special_info['sub_subject'] = ""
    return outstring

@  Compound statements

<<Compound statements>>=
    elif node_type == "IF_EXPR":   #IF_EXPR test true_suite false_suite
        outstring = "if "
        outstring = outstring + traverse_ast(in_node[1])
        outstring = outstring + ":"
        true_bit = traverse_ast(in_node[2])
        outstring = outstring + add_indent("\n"+true_bit)  #indent
        if len(in_node)>3:
            outstring = outstring + "\nelse:"
            false_bit = traverse_ast(in_node[3])
            outstring = outstring + add_indent("\n"+false_bit)  #indent
        return outstring

# dREL for statements include the final value, whereas a python range will include
# everything up to the final number
    elif node_type == "DO":    #DO ID = start, finish, incr, suite
        outstring = "for " + in_node[1] + " in range(" + traverse_ast(in_node[2]) + ","
        finish = traverse_ast(in_node[3])
        increment = traverse_ast(in_node[4])
        outstring = outstring + finish + "+1" + "," + increment
        outstring = outstring + "):"
        suite = add_indent("\n"+traverse_ast(in_node[5]))
        return outstring + suite
    elif node_type == "FOR": # FOR target_list expression_list suite
        outstring = "for "
        for express in in_node[1]:
            outstring = outstring + traverse_ast(express) + ","
        outstring = outstring[:-1] + " in "
        for target in in_node[2]:
            outstring += traverse_ast(target) + ","
        outstring = outstring[:-1] + ":" + add_indent("\n" + traverse_ast(in_node[3]))
        return outstring
    elif node_type == "REPEAT": #REPEAT suite
        outstring = "while True:" + add_indent("\n" + traverse_ast(in_node[1]))
    <<With statements>>
    <<Loop statements>>
    <<Function definitions>>

@  With statements.  ``With'' in dREL is ultimately just a simple alias (see separate document discussing this) if we consider that a looped item
method is necessarily mapped across all packets of the category, or in other
words it can only operate on the 'current packet'.  So we make
a memo of the aliases that are currently in use and don't actually
output anything.

<<With statements>>=
elif node_type == "WITH": #old_id new_id suite
    # each entry in special_id is [alias:[cat_name,loop variable, is_loop]]
    alias_id = in_node[1]
    cat_id = in_node[2]
    special_info['special_id'][-1].update({alias_id:[cat_id,"",False]})
    if in_node[2] in special_info['loopable_cats']: #flat this
        if len(special_info['withtable'])!= 0:
            raise CifError, "Error: cannot map over two categories in single method"
        special_info['special_id'][-1][1] = "looped_cat"
    outstring = traverse_ast(in_node[3])
    return outstring

@ Loop statements involve running over all packets in a category, substituting
for datanames as necessary and inserting the packet index as well.
    
<<Loop statements>>=
elif node_type == "LOOP": #ALIAS CAT LOOPVAR COMP COMPVAR SUITE 
    alias_id = in_node[1]
    cat_id = in_node[2]
    var_info = [cat_id,"",False]
    if cat_id in special_info['loopable_cats']:  #loop over some index
        if in_node[3] == "":  # provide our own
            loop_index = "__pi%d" % (len(special_info['special_id'][-1])+1)
        else:
            loop_index = in_node[3]
        var_info[1] = loop_index
        var_info[2] = True
    special_info['special_id'][-1].update({alias_id:var_info})
    # now emit some text: first to find the length of the category
    outstring = "__pycitems = self.names_in_cat('%s')" % cat_id
    outstring += "\nprint 'names in cat = %s' % `__pycitems`"
    outstring += "\n" + "__pycitems = filter(lambda a:ciffile.has_key(a),__pycitems)"
    outstring += "\nprint 'names in cat -> %s' % `__pycitems`\n"
    if var_info[2] == True:
        outstring += "\n" + "__loop_range = range(len(ciffile[__pycitems[0]]))"
    else:
        outstring += "\n" + "__loop_range = [0]"
        #outstring +="\n" + "for __noloop in [0]:"
    # deal with this comparison test
    if in_node[4] != "":
        outstring += "\n" + "__loop_range = [a for a in __loop_range if a %s %s]" % (in_node[4],in_node[5])
    # now output the looping command
    outstring += "\n" + "for %s in __loop_range:" % loop_index
    # now the actual body of the loop
    loop_body = traverse_ast(in_node[6])
    outstring = outstring + add_indent("\n"+loop_body)
    return outstring

@  Function arguments can have their types explicitly specified, but we don't make use
of this.

<<Function definitions>>=
elif node_type == "FUNCTION":   #FUNCTION ID ARGLIST SUITE
    func_name = in_node[1]
    outstring = "def %s (" % func_name
    for one_arg in in_node[2]:
        outstring += one_arg[0] + ","
    outstring = outstring[:-1] + "):"
    outstring = outstring + add_indent("\n" + traverse_ast(in_node[3])+"\nreturn %s" % func_name)
    return outstring

@  \section{Top level constructions}. 
Ultimately we end up with a list of statements.

<<Top level constructions>>=
    elif node_type == "STATEMENTS":
        outstring = ""
        for one_statement in in_node[1]:
#            try:
                outstring = outstring + traverse_ast(one_statement) + "\n" 
#            except SyntaxError, message:
#                outstring += "raise SyntaxError, %s" % message
#            except:
#                outstring += "raise SyntaxError, %s" % `one_statement`
        return outstring
    <<Assignment statements>>
    elif node_type == "LIST":
        outstring = "[" 
        for one_element in in_node[1]:
            outstring = outstring + traverse_ast(one_element)  + ","
        return outstring + "]"
    elif node_type == "EXPR":
        return traverse_ast(in_node[1])
    # Expr list occurs only when a non-assignment statement appears as expr_stmt
    elif node_type == "EXPRLIST":
        outstring = ""
        for one_expr in in_node[1]:
            outstring += traverse_ast(one_expr) + "\n"
        return outstring
    elif node_type == "GROUP":
        outstring = "("
        for expression in in_node[1]:
             outstring = outstring + traverse_ast(expression) + ","
        return outstring[:-1] + ")"
    elif node_type == "PRINT":
        return 'print ' + traverse_ast(in_node[1])
    elif node_type == "BREAK":
        return 'break '
    elif node_type == "NEXT":
        return 'continue '

@  Assignment. The category-level assignments write to a table indexed by
object id, so the final result will be a set of list-valued datanames for
insertion into the ciffile.

<<Assignment statements>>=
elif node_type == "ASSIGN":  #Target_list ,assigner, expression list
    outstring = ""
    for target_value in in_node[1]:
        outstring = outstring + traverse_ast(target_value)+","
    outstring = outstring[:-1] + in_node[2]
    for expression in in_node[3]:
        outstring = outstring + traverse_ast(expression)+","
    return outstring[:-1]
elif node_type == "FANCY_ASSIGN":  # [1] is cat name, [2] is list of objects
    catname = in_node[1]
    outstring = ""
    for obj,value in in_node[2]:
        real_id = "_" + catname + "." + obj
        newvalue = traverse_ast(value)
        outstring = outstring + "__dreltarget.update({'%s':__dreltarget.get('%s',[])+[%s]})\n" % (real_id,real_id,newvalue)
    return outstring 


@  Maths.  We have to catch vector and matrix operations and farm them out
to numpy. Not implemented yet.  A binary maths operation is 'mathop'.  We
take a shortcut and assume that the operators are written identically in
dREL and python, so that the AST contains the textual form of the operator.

<<Maths>>=
    elif node_type == "MATHOP":
        op = mathop_table[in_node[1]]
        outstring = traverse_ast(in_node[2]) + op + traverse_ast(in_node[3])
        return outstring
    elif node_type == "SIGN":
        outstring = in_node[1] + traverse_ast(in_node[2])
        return outstring
    elif node_type == "UNARY":
        outstring = in_node[1] + " " + traverse_ast(in_node[2])
        return outstring

@  Although in most cases we could simply directly write in the binary maths
operator, we do a table lookup to facilitate reuse of this code with other
language targets.

<<Maths operator conversion table>>=
mathop_table = {"+":"+", "-":"-", "<":"<", "*":"*", "/":"/",
                ">":">", "<=":"<=", ">=":">=", "!=":"!=",
                "or":" or ", "and":" and ",
                "==":"==", "in":" in ", "not in":" not in "}

@ To avoid cluttering up the main switch statement, we call out to this function
in order to find out what the Python name of the given function is.  Where we have
to provide our own function, that is also listed.
  
<<Function transformer>>=
def get_function_name(in_name):
    """Return the Python name of the dREL function, an argument prefix,
       and anything to be appended to the end"""
    builtins = {"list":"StarFile.StarList",
                "tuple":"StarFile.StarTuple",
                "table":"dict",
                "int":"int",
                "len":"len",
                "abs":"abs"}
    test_name = in_name.lower()
    target_name = builtins.get(test_name,None)
    if target_name is not None:
        return target_name,"",""
    if test_name in ['sind','cosd','tand']:
        return "math."+target_name[:3],"math.radians*",""
    if test_name in ['array']:
        return "numpy.array","",""
    if test_name == "mod":
        return "divmod","","[1]"
    return in_name,"",""   #no idea
 
@  We keep a track of any categories that are aliased by the method so that
we can explicitly pass those categories as an argument of the function. The
following method traverses the AST to pick up all such aliases.

<<With finder>>=
def find_withs(in_ast):
    """Return all loop categories that are aliased with with statements"""
    pass

<<Utility functions>>=
def add_indent(text,n=4):
    """Indent text by n spaces"""
    return re.sub("\n","\n"+4*" ",text)
 
